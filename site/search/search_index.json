{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TappyTap Documentation","text":"<p>The time of the tap hath come!</p> <p>Found an error in our documentation? Please let us know!</p>"},{"location":"about/","title":"About","text":""},{"location":"hwdocs/","title":"Actuator Panels","text":"<p>TappyTap is currently available in two forms: the Swatch and the Palm. Both are intended as development tools, with the Swatch being general purpose (i.e. could be worn anywhere on your body or on another interactive surface) and the Palm being application specific (i.e. worn on your hand).</p>"},{"location":"hwdocs/#swatch","title":"Swatch","text":"<p>The Swatch is a generic sheet. It has 18x24 tappers.</p>"},{"location":"hwdocs/#palm","title":"Palm","text":"<p>The Palm is a sheet of TappyTap fabric sized for the palm of your hand (if your hand is the same size as ours).</p>"},{"location":"hwdocs/#controller","title":"Controller","text":"<p>The Controller is a Bluetooth enabled device for controlling the tappers in the fabric systems.</p>"},{"location":"hwdocs/#battery-pcb","title":"Battery PCB","text":"<p>The Battery PCB is a single cell LiPo battery protection circuit + monitor.</p>"},{"location":"hwdocs/#battery-charger","title":"Battery Charger","text":"<p>The Battery Charger can charge 2 battery packs at a time, each at 370mA peak current. </p>"},{"location":"swdocs/","title":"Dev Page Documentation","text":""},{"location":"swdocs/#installation-requirements","title":"Installation Requirements","text":"<ul> <li>install nodejs</li> <li>instal bun ( https://bun.sh )</li> </ul> <p>then in terminal, run:</p> <pre><code>bun install\n</code></pre>"},{"location":"swdocs/#running","title":"Running","text":"<p>Open two terminals, in the tapmeta directory and run:</p> <p>Terminal 1:</p> <pre><code>cd packages/tapcanvas\nbun run dev\n</code></pre> <p>Terminal 2:</p> <pre><code>cd packages/tapserver\nbun run dev\n</code></pre>"},{"location":"swdocs/#building","title":"Building","text":"<pre><code>cd packages/tapcanvas\nbun run build\n</code></pre>"},{"location":"swdocs/#running-build","title":"Running Build","text":"<pre><code>cd packages/tapcanvas\nbun run build &amp;&amp; bunx serve -n .\nhttp://localhost:3000/app-dev/\n</code></pre>"},{"location":"swdocs/#publishing","title":"Publishing","text":"<pre><code>cd packages/tapcanvas\nbun publish.js\n</code></pre>"},{"location":"swdocs/#running-chrome","title":"Running chrome:","text":"<pre><code>/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --app=\"https://localhost:8581/app-dev/\"\n</code></pre>"},{"location":"fwdocs/","title":"Firmware Documentation","text":"<ul> <li>Communication Protocol</li> <li>Compiling the Controller Firmware</li> <li>Controller Firmware Overview</li> <li>Battery PCB Firmware Overview</li> </ul>"},{"location":"fwdocs/batteryfw/","title":"Battery PCB Firmware Overview","text":"<p>The Battery PCB firmware can be found here.</p>"},{"location":"fwdocs/compiling/","title":"Compiling the Firmware","text":"<p>This project uses re-compiled arduino-esp32 core libraries using the esp32-arduino-lib-builder project, and it is structured for compilation with PlatformIO. I'm not an expert with PlatformIO, ESP-IDF, the library builder, etc. so I'd recommend following other guides to get those all set up first.</p>"},{"location":"fwdocs/compiling/#steps-for-building-new-core-libraries","title":"Steps for Building New Core Libraries","text":"<ol> <li> <p>Edit <code>esp32-arduino-lib-builder/configs/defconfig.esp32s3</code> (settings for this project are located in the documentation folder)</p> </li> <li> <p>In a terminal window, navigate to the <code>esp32-arduino-lib-builder</code> folder and enter:     <code>bash     rm -rf build # remove the existing build files if you've already compiled them     rm -rf components/esp-rainmaker # I had to do this to get my build on Oct 2 to work, may not be necessary now     ./build.sh -t esp32s3 -I idf-release/v5.1     ./tool/copy-to-arduino # if using arduino, or copy the files listed in the script to the relevant location for platformIO - I believe it is /Users/[your_username]/.platformio/packages/framework-arduinoespressif32</code> Note regarding the rainmaker module: I last built core files on Oct. 2, 2023, and encountered an error similar to this GitHub issue. For me, pulling the latest update (even fully re-installing the repository) didn't resolve the issue, so I added a specific line to the <code>update-components.sh</code> file and removed the existing rainmaker component with the command above.</p> </li> </ol> <pre><code>#\n# CLONE/UPDATE ESP-RAINMAKER\n#\necho \"Updating ESP-RainMaker...\"\nif [ ! -d \"$AR_COMPS/esp-rainmaker\" ]; then\n    git clone $RMAKER_REPO_URL \"$AR_COMPS/esp-rainmaker\" &amp;&amp; \\\n    git -C \"$AR_COMPS/esp-rainmaker\" checkout 0414a8530ec1ac8714269302503c71c238b68836 # &lt;------ this line\n    git -C \"$AR_COMPS/esp-rainmaker\" submodule update --init --recursive\nelse\n    git -C \"$AR_COMPS/esp-rainmaker\" fetch &amp;&amp; \\\n    git -C \"$AR_COMPS/esp-rainmaker\" pull --ff-only &amp;&amp; \\\n    git -C \"$AR_COMPS/esp-rainmaker\" submodule update --init --recursive\nfi\nif [ $? -ne 0 ]; then exit 1; fi\n</code></pre>"},{"location":"fwdocs/controllerfw/","title":"Controller Firmware Overview","text":"<p>The Controller firmware can be found here.</p> <p></p>"},{"location":"fwdocs/protocol/","title":"Communication Protocol for Client Device and TappyTap Controller","text":"<p>This section outlines the communication protocol for a client device to connect to a the TappyTap Controller using Bluetooth 5 (LE). see 'script.js' in the examples folder for an implementation of this protocol.</p>"},{"location":"fwdocs/protocol/#connecting-to-the-driver-board","title":"Connecting to the Controller","text":"<p>The Controller advertises itself as a BLE server with the service UUID <code>4fafc201-1fb5-459e-8fcc-c5c9c331914b</code>. The client device should initiate a scan for BLE devices and look for the one advertising this service UUID. Once found, the client device should establish a connection to the BLE server (the Controller).</p>"},{"location":"fwdocs/protocol/#sending-messages-to-the-driver-board","title":"Sending Messages to the Controller","text":"<p>To send a message from the client device to the Controller, the client device should write to the BLE characteristic with the UUID <code>beb5483e-36e1-4688-b7f5-ea07361b26a8</code>.</p>"},{"location":"fwdocs/protocol/#sent-message-types-and-structure","title":"Sent Message Types and Structure","text":"<ul> <li> <p><code>TAP_OUT</code>: Byte code <code>1</code>. The message should follow this structure:</p> <ul> <li>Byte 0: <code>1</code></li> <li>Byte 1: idenfication number that is published along with the confirmation when the TAP_OUT sequence is completed</li> <li>Byte 2 to n: row and column index pairs for the tap sequences. Each pair consists of the row index followed by the column index. For example, the message 0x01 0xFF 0x00 0x00 0x01 0x01 = [TAP_OUT] [Identifier (FF)] [ROW 0] [COL 0] [ROW 1] [COL 1]. Row/col pairs will be tapped out according to the parameters set with TAP_CONFIG, with the pair after the TAP_OUT byte tapped first.<ul> <li>if there are no bytes after the identifier, the current TAP_OUT sequence will be cancelled.</li> </ul> </li> </ul> </li> <li> <p><code>TAP_CONFIG</code>: Byte code <code>2</code>. The message should follow this structure:</p> <ul> <li>Byte 0: <code>2</code></li> <li>Byte 1: <code>onDur</code> (in tenths of a ms, i.e. hundreds of microseconds); range is 1-30</li> <li>Byte 2: <code>offDur</code> (in ms); range is 10-255</li> <li>Byte 3: <code>repeatDelay</code> (in ms); range is 2-255</li> <li>Byte 4: <code>repeatCT</code> (number of repetitions; 1 = tap once); range is 1-5</li> </ul> </li> <li> <p><code>CHECK_BATTERY</code>: Byte code <code>3</code>.</p> </li> <li> <p><code>TAP_OUT_EXPLICIT</code>: Byte code <code>4</code>. The message should follow this structure:</p> <ul> <li>Byte 0: <code>4</code></li> <li>Byte 1: idenfication number that is published along with the confirmation when the TAP_OUT sequence is completed</li> <li>Byte 2 to n: row and column index pairs for the tap sequences, as well as on duration and off duration for each tap. Data is ordered as: [row] [col] [onDuration] [offDuration]. For example, the message 0x04 0xFF 0x00 0x00 0x0A 0x19 0x01 0x01 0x14 0x32 = [TAP_OUT] [Identifier (FF)] [ROW 0] [COL 0] [ON DURATION 1ms] [OFF DURATION 25ms] [ROW 1] [COL 1] [ON DURATION 2ms] [OFF DURATION 50ms]. Currently this will cause repeatCT to be set to 1 (i.e. taps are not repeated). Row/col pairs will be tapped out with the pair after the TAP_OUT byte tapped first. Note that on duration values are converted into hundreds of microseconds, e.g. 0x01 = 100us = 0.1ms.<ul> <li>if there are no bytes after the identifier, the current TAP_OUT sequence will be cancelled.</li> </ul> </li> </ul> </li> <li> <p><code>GET_VERSION</code>: Byte code <code>5</code>.</p> </li> <li> <p><code>START_IMU_STREAM</code>: Byte code <code>6</code>.</p> </li> <li> <p><code>STOP_IMU_STREAM</code>: Byte code <code>7</code>.</p> </li> <li> <p>'TAP_ALL': Byte code '8'. The message should follow this structure:</p> <ul> <li>Byte 0: <code>4</code></li> <li>Byte 1: idenfication number that is published along with the confirmation when the TAP_OUT sequence is completed</li> <li>Byte 2: on duration (tenths of a millisecond) that will be used for all taps in the pattern; follows the same limits as TAP_OUT and TAP_OUT_EXPLICIT</li> <li>Byte 3: off duration (tenths of a milliseond - note that this is different from TAP_OUT and TAP_OUT_EXPLICIT which use ms for off duration) that will be used for all taps in the pattern. The lower limit is 0 (no delay), the upper limit is the same as for TAP_OUT and TAP_OUT_EXPLICIT.</li> <li>Byte 4 to n: row and column index pairs for the tap sequences</li> </ul> </li> </ul>"},{"location":"fwdocs/protocol/#receiving-messages-from-the-driver-board","title":"Receiving Messages from the Controller","text":"<p>The client device should also monitor the same BLE characteristic (UUID <code>beb5483e-36e1-4688-b7f5-ea07361b26a8</code>) for notifications to receive messages from the Controller.</p>"},{"location":"fwdocs/protocol/#received-message-types-and-structure","title":"Received Message Types and Structure","text":"<ul> <li> <p><code>CONFRIM_RECEIVED</code>: Byte code <code>1</code>. This message is sent to the client device to acknowledge that the sent message has been received and processed. This is only sent if the message was error free; otherwise an error code is sent instead.</p> </li> <li> <p><code>TAPOUT_COMPLETE</code>: Byte code <code>2</code>. This message contains 2 bytes; the first is the byte code and the second is the identifying byte sent to the microcontroller along with the TAP_OUT command. This message is sent to the client device to indicate that the tap out sequence has been completed.</p> </li> <li> <p><code>BATTERY_PERCENT</code>: Byte code <code>3</code>. This message contains 2 bytes; the first is the byte code and the second is the estimated remaining percentage of charge remaining in the battery pack.</p> </li> <li> <p><code>GET_VERSION</code>: Byte code <code>4</code>. This message contains 6 bytes; the first is the byte code, then in order: hardware version number major, hardware version number minor, firmware version number major, firmware version number minor, firmware version patch. Version numbers can be read as: Hardware Version [major].[minor], Firmware Version [major].[minor].[patch].</p> </li> <li> <p><code>IMU_DATA</code>: Byte code <code>5</code>. This message contains 25 bytes; the first is the byte code and the next 24 are the 6 data values polled from the IMU (acceleration x y z and gyro x y z in that order). After collecting the data as floats, the controller multiplies them by 1000 and converts them into int32 values (preserving 3 decimal places), then splits them into 4 bytes each (MSB first). </p> </li> <li> <p><code>INVALID_MSG_TYPE</code>: Byte code <code>51</code>. This message contains 2 bytes; the first is the byte code and the second is the invalid message tpye that was received</p> </li> <li> <p><code>INCORRECT_MSG_SIZE</code>: Byte code <code>52</code>. This message contains 2 bytes; the first is the byte code and the second is the size of the received message, including the sent byte code</p> </li> <li> <p><code>PARAM_OOB</code>: Byte code <code>53</code>. This message contains 2 bytes; the first is the byte code and the second is the position of the message parameter that is out of bounds. If multiple parameters are OOB, the position of the last one will be sent. For TAP_CONFIG messages, the last received parameter will stay the same (or it will be the default parameter value if no valid config message has been received yet), and a flag is raised to indicate that the last TAP_CONFIG received was invalid (CONFIG_INVALID, see below). This flag is sent each time a new TAP_OUT message is received until a valid TAP_CONFIG message is received For TAP_ALL messages, invalid parameters are replaced with hard coded default values.</p> </li> <li> <p><code>CONFIG_INVALID</code>: Byte code <code>54</code>. This message is sent to the client device when a TAP_OUT message is received but the last TAP_CONFIG message had an error in it.</p> </li> <li> <p><code>ROW_INDEX_OOB</code>: Byte code <code>55</code>. This message contains 2 bytes; the first is the byte code and the second is the position of the out of bounds row index. When an out of bounds index is received, the firmware will not tap an actuator, but it will still use the timing of a normal tap, and continue with the rest of the in bounds taps. If multiple indicies are out of bounds, only the position of the last one will be sent. If a column with a larger index is also OOB, it will be reported instead.</p> </li> <li> <p><code>COL_INDEX_OOB</code>: Byte code <code>56</code>. This message contains 2 bytes; the first is the byte code and the second is the position of the out of bounds column index. When an out of bounds index is received, the firmware will not tap an actuator, but it will still use the timing of a normal tap, and continue with the rest of the in bounds taps. If multiple indicies are out of bounds, only the position of the last one will be sent. If a row with the same or larger index is also OOB, it will be reported instead.</p> </li> <li> <p><code>OVERTAP_WARNING</code>: Byte code <code>57</code>. This message is sent to the client device when the TAP_CONFIG parameters have set the combination of onDur, repeatCT, and repeatDelay too high. onDur is automatically reduced to a safer value.</p> </li> <li> <p><code>DAMAGED_TAPPER</code>: Byte code <code>58</code>. This message contains 3 bytes; the first is the byte code, the second is the row index and the third is the column index. This message is sent when the current measured for a tap doesn't exceed the minimum value considered normal/healthy. </p> </li> <li> <p><code>OC_EVENT</code>: Byte code <code>59</code>. This message is sent when an overcurrent event is detected, i.e. when the on board analog circuitry detects a sustained current being drawn by the H-bridge driver ICs. The on board circuitry automatically disables the H bridge outputs. This should only happen in an event where the controller turns an output on and then somehow misses turning it off (e.g. if an SPI timing error causes a write commend to be missed) because the tap configuration settings should prevent a user from entering tap on-durations from reaching this threshold. In cases where the controller crashes mid-tap, this message will likely not be generated.</p> </li> <li> <p><code>BATTERY_POLL_COOLDOWN</code>: Byte code <code>60</code>. This message is sent to the client device when the controller receives a battery poll request too quickly after a perviously sent request.</p> </li> <li> <p><code>OTA_TIMEOUT</code>: Byte code <code>61</code>. This message is sent to the client device when the controller receives an OTA upload request but the user doesn't press the 'user button' before the timeout period.</p> </li> </ul>"}]}