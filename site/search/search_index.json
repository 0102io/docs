{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TappyTap Documentation The time of the tap hath come! Found an error in our documentation? Please let us know !","title":"Home"},{"location":"#tappytap-documentation","text":"The time of the tap hath come! Found an error in our documentation? Please let us know !","title":"TappyTap Documentation"},{"location":"about/","text":"About","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"hwdocs/","text":"Actuator Panels TappyTap is currently available in two forms: the Swatch and the Palm. Both are intended as development tools, with the Swatch being general purpose (i.e. could be worn anywhere on your body or on another interactive surface) and the Palm being application specific (i.e. worn on your hand). Swatch The Swatch is a generic sheet. It has 18x24 tappers. Palm The Palm is a sheet of TappyTap fabric sized for the palm of your hand (if your hand is the same size as ours). Controller The Controller is a Bluetooth enabled device for controlling the tappers in the fabric systems. Battery PCB The Battery PCB is a single cell LiPo battery protection circuit + monitor. Battery Charger The Battery Charger can charge 2 battery packs at a time, each at 370mA peak current.","title":"Hardware"},{"location":"hwdocs/#actuator-panels","text":"TappyTap is currently available in two forms: the Swatch and the Palm. Both are intended as development tools, with the Swatch being general purpose (i.e. could be worn anywhere on your body or on another interactive surface) and the Palm being application specific (i.e. worn on your hand).","title":"Actuator Panels"},{"location":"hwdocs/#swatch","text":"The Swatch is a generic sheet. It has 18x24 tappers.","title":"Swatch"},{"location":"hwdocs/#palm","text":"The Palm is a sheet of TappyTap fabric sized for the palm of your hand (if your hand is the same size as ours).","title":"Palm"},{"location":"hwdocs/#controller","text":"The Controller is a Bluetooth enabled device for controlling the tappers in the fabric systems.","title":"Controller"},{"location":"hwdocs/#battery-pcb","text":"The Battery PCB is a single cell LiPo battery protection circuit + monitor.","title":"Battery PCB"},{"location":"hwdocs/#battery-charger","text":"The Battery Charger can charge 2 battery packs at a time, each at 370mA peak current.","title":"Battery Charger"},{"location":"swdocs/","text":"Dev Page Documentation Installation Requirements install nodejs instal bun ( https://bun.sh ) then in terminal, run: bun install Running Open two terminals, in the tapmeta directory and run: Terminal 1: cd packages/tapcanvas bun run dev Terminal 2: cd packages/tapserver bun run dev Building cd packages/tapcanvas bun run build Running Build cd packages/tapcanvas bun run build && bunx serve -n . http://localhost:3000/app-dev/ Publishing cd packages/tapcanvas bun publish.js Running chrome: /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --app=\"https://localhost:8581/app-dev/\"","title":"Software"},{"location":"swdocs/#dev-page-documentation","text":"","title":"Dev Page Documentation"},{"location":"swdocs/#installation-requirements","text":"install nodejs instal bun ( https://bun.sh ) then in terminal, run: bun install","title":"Installation Requirements"},{"location":"swdocs/#running","text":"Open two terminals, in the tapmeta directory and run: Terminal 1: cd packages/tapcanvas bun run dev Terminal 2: cd packages/tapserver bun run dev","title":"Running"},{"location":"swdocs/#building","text":"cd packages/tapcanvas bun run build","title":"Building"},{"location":"swdocs/#running-build","text":"cd packages/tapcanvas bun run build && bunx serve -n . http://localhost:3000/app-dev/","title":"Running Build"},{"location":"swdocs/#publishing","text":"cd packages/tapcanvas bun publish.js","title":"Publishing"},{"location":"swdocs/#running-chrome","text":"/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --app=\"https://localhost:8581/app-dev/\"","title":"Running chrome:"},{"location":"fwdocs/","text":"Firmware Documentation Communication Protocol Compiling the Controller Firmware Controller Firmware Overview Battery PCB Firmware Overview","title":"Overview"},{"location":"fwdocs/#firmware-documentation","text":"Communication Protocol Compiling the Controller Firmware Controller Firmware Overview Battery PCB Firmware Overview","title":"Firmware Documentation"},{"location":"fwdocs/batteryfw/","text":"Battery PCB Firmware Overview The Battery PCB firmware can be found here .","title":"Battery PCB Firmware Overview"},{"location":"fwdocs/batteryfw/#battery-pcb-firmware-overview","text":"The Battery PCB firmware can be found here .","title":"Battery PCB Firmware Overview"},{"location":"fwdocs/compiling/","text":"Compiling the Firmware This project uses re-compiled arduino-esp32 core libraries using the esp32-arduino-lib-builder project , and it is structured for compilation with PlatformIO. I'm not an expert with PlatformIO, ESP-IDF, the library builder, etc. so I'd recommend following other guides to get those all set up first. Steps for Building New Core Libraries Edit esp32-arduino-lib-builder/configs/defconfig.esp32s3 (settings for this project are located in the documentation folder) In a terminal window, navigate to the esp32-arduino-lib-builder folder and enter: bash rm -rf build # remove the existing build files if you've already compiled them rm -rf components/esp-rainmaker # I had to do this to get my build on Oct 2 to work, may not be necessary now ./build.sh -t esp32s3 -I idf-release/v5.1 ./tool/copy-to-arduino # if using arduino, or copy the files listed in the script to the relevant location for platformIO - I believe it is /Users/[your_username]/.platformio/packages/framework-arduinoespressif32 Note regarding the rainmaker module: I last built core files on Oct. 2, 2023, and encountered an error similar to this GitHub issue . For me, pulling the latest update (even fully re-installing the repository) didn't resolve the issue, so I added a specific line to the update-components.sh file and removed the existing rainmaker component with the command above. # # CLONE/UPDATE ESP-RAINMAKER # echo \"Updating ESP-RainMaker...\" if [ ! -d \"$AR_COMPS/esp-rainmaker\" ]; then git clone $RMAKER_REPO_URL \"$AR_COMPS/esp-rainmaker\" && \\ git -C \"$AR_COMPS/esp-rainmaker\" checkout 0414a8530ec1ac8714269302503c71c238b68836 # <------ this line git -C \"$AR_COMPS/esp-rainmaker\" submodule update --init --recursive else git -C \"$AR_COMPS/esp-rainmaker\" fetch && \\ git -C \"$AR_COMPS/esp-rainmaker\" pull --ff-only && \\ git -C \"$AR_COMPS/esp-rainmaker\" submodule update --init --recursive fi if [ $? -ne 0 ]; then exit 1; fi","title":"Compiling the Controller Firmware"},{"location":"fwdocs/compiling/#compiling-the-firmware","text":"This project uses re-compiled arduino-esp32 core libraries using the esp32-arduino-lib-builder project , and it is structured for compilation with PlatformIO. I'm not an expert with PlatformIO, ESP-IDF, the library builder, etc. so I'd recommend following other guides to get those all set up first.","title":"Compiling the Firmware"},{"location":"fwdocs/compiling/#steps-for-building-new-core-libraries","text":"Edit esp32-arduino-lib-builder/configs/defconfig.esp32s3 (settings for this project are located in the documentation folder) In a terminal window, navigate to the esp32-arduino-lib-builder folder and enter: bash rm -rf build # remove the existing build files if you've already compiled them rm -rf components/esp-rainmaker # I had to do this to get my build on Oct 2 to work, may not be necessary now ./build.sh -t esp32s3 -I idf-release/v5.1 ./tool/copy-to-arduino # if using arduino, or copy the files listed in the script to the relevant location for platformIO - I believe it is /Users/[your_username]/.platformio/packages/framework-arduinoespressif32 Note regarding the rainmaker module: I last built core files on Oct. 2, 2023, and encountered an error similar to this GitHub issue . For me, pulling the latest update (even fully re-installing the repository) didn't resolve the issue, so I added a specific line to the update-components.sh file and removed the existing rainmaker component with the command above. # # CLONE/UPDATE ESP-RAINMAKER # echo \"Updating ESP-RainMaker...\" if [ ! -d \"$AR_COMPS/esp-rainmaker\" ]; then git clone $RMAKER_REPO_URL \"$AR_COMPS/esp-rainmaker\" && \\ git -C \"$AR_COMPS/esp-rainmaker\" checkout 0414a8530ec1ac8714269302503c71c238b68836 # <------ this line git -C \"$AR_COMPS/esp-rainmaker\" submodule update --init --recursive else git -C \"$AR_COMPS/esp-rainmaker\" fetch && \\ git -C \"$AR_COMPS/esp-rainmaker\" pull --ff-only && \\ git -C \"$AR_COMPS/esp-rainmaker\" submodule update --init --recursive fi if [ $? -ne 0 ]; then exit 1; fi","title":"Steps for Building New Core Libraries"},{"location":"fwdocs/controllerfw/","text":"Controller Firmware Overview The Controller firmware can be found here .","title":"Controller Firmware Overview"},{"location":"fwdocs/controllerfw/#controller-firmware-overview","text":"The Controller firmware can be found here .","title":"Controller Firmware Overview"},{"location":"fwdocs/protocol/","text":"Communication Protocol for Client Device and TappyTap Driver Board This section outlines the communication protocol for a client device to connect to a the TappyTap Driver Board using Bluetooth 5 (LE). see 'script.js' in the examples folder for an implementation of this protocol. Connecting to the Driver Board The Driver Board advertises itself as a BLE server with the service UUID 4fafc201-1fb5-459e-8fcc-c5c9c331914b . The client device should initiate a scan for BLE devices and look for the one advertising this service UUID. Once found, the client device should establish a connection to the BLE server (the Driver Board). Sending Messages to the Driver Board To send a message from the client device to the Driver Board, the client device should write to the BLE characteristic with the UUID beb5483e-36e1-4688-b7f5-ea07361b26a8 . Sent Message Types and Structure TAP_OUT : Byte code 1 . The message should follow this structure: Byte 0: 1 Byte 1: idenfication number that is published along with the confirmation when the TAP_OUT sequence is completed Byte 2 to n: row and column index pairs for the tap sequences. Each pair consists of the row index followed by the column index. For example, the message 0x01 0xFF 0x00 0x00 0x01 0x01 = [TAP_OUT] [Identifier (FF)] [ROW 0] [COL 0] [ROW 1] [COL 1]. Row/col pairs will be tapped out according to the parameters set with TAP_CONFIG, with the pair after the TAP_OUT byte tapped first. if there are no bytes after the identifier, the current TAP_OUT sequence will be cancelled. TAP_CONFIG : Byte code 2 . The message should follow this structure: Byte 0: 2 Byte 1: onDur (in tenths of a ms, i.e. hundreds of microseconds); range is 1-30 Byte 2: offDur (in ms); range is 10-255 Byte 3: repeatDelay (in ms); range is 2-255 Byte 4: repeatCT (number of repetitions; 1 = tap once); range is 1-5 CHECK_BATTERY : Byte code 3 . TAP_OUT_EXPLICIT : Byte code 4 . The message should follow this structure: Byte 0: 4 Byte 1: idenfication number that is published along with the confirmation when the TAP_OUT sequence is completed Byte 2 to n: row and column index pairs for the tap sequences, as well as on duration and off duration for each tap. Data is ordered as: [row] [col] [onDuration] [offDuration]. For example, the message 0x04 0xFF 0x00 0x00 0x0A 0x19 0x01 0x01 0x14 0x32 = [TAP_OUT] [Identifier (FF)] [ROW 0] [COL 0] [ON DURATION 1ms] [OFF DURATION 25ms] [ROW 1] [COL 1] [ON DURATION 2ms] [OFF DURATION 50ms]. Currently this will cause repeatCT to be set to 1 (i.e. taps are not repeated). Row/col pairs will be tapped out with the pair after the TAP_OUT byte tapped first. Note that on duration values are converted into hundreds of microseconds, e.g. 0x01 = 100us = 0.1ms. if there are no bytes after the identifier, the current TAP_OUT sequence will be cancelled. GET_VERSION : Byte code 5 . START_IMU_STREAM : Byte code 6 . STOP_IMU_STREAM : Byte code 7 . 'TAP_ALL': Byte code '8'. The message should follow this structure: Byte 0: 4 Byte 1: idenfication number that is published along with the confirmation when the TAP_OUT sequence is completed Byte 2: on duration (tenths of a millisecond) that will be used for all taps in the pattern; follows the same limits as TAP_OUT and TAP_OUT_EXPLICIT Byte 3: off duration (tenths of a milliseond - note that this is different from TAP_OUT and TAP_OUT_EXPLICIT which use ms for off duration) that will be used for all taps in the pattern. The lower limit is 0 (no delay), the upper limit is the same as for TAP_OUT and TAP_OUT_EXPLICIT. Byte 4 to n: row and column index pairs for the tap sequences Receiving Messages from the Driver Board The client device should also monitor the same BLE characteristic (UUID beb5483e-36e1-4688-b7f5-ea07361b26a8 ) for notifications to receive messages from the Driver Board. Received Message Types and Structure CONFRIM_RECEIVED : Byte code 1 . This message is sent to the client device to acknowledge that the sent message has been received and processed. This is only sent if the message was error free; otherwise an error code is sent instead. TAPOUT_COMPLETE : Byte code 2 . This message contains 2 bytes; the first is the byte code and the second is the identifying byte sent to the microcontroller along with the TAP_OUT command. This message is sent to the client device to indicate that the tap out sequence has been completed. BATTERY_PERCENT : Byte code 3 . This message contains 2 bytes; the first is the byte code and the second is the estimated remaining percentage of charge remaining in the battery pack. GET_VERSION : Byte code 4 . This message contains 6 bytes; the first is the byte code, then in order: hardware version number major, hardware version number minor, firmware version number major, firmware version number minor, firmware version patch. Version numbers can be read as: Hardware Version [major].[minor], Firmware Version [major].[minor].[patch]. IMU_DATA : Byte code 5 . This message contains 25 bytes; the first is the byte code and the next 24 are the 6 data values polled from the IMU (acceleration x y z and gyro x y z in that order). After collecting the data as floats, the controller multiplies them by 1000 and converts them into int32 values (preserving 3 decimal places), then splits them into 4 bytes each (MSB first). INVALID_MSG_TYPE : Byte code 51 . This message contains 2 bytes; the first is the byte code and the second is the invalid message tpye that was received INCORRECT_MSG_SIZE : Byte code 52 . This message contains 2 bytes; the first is the byte code and the second is the size of the received message, including the sent byte code PARAM_OOB : Byte code 53 . This message contains 2 bytes; the first is the byte code and the second is the position of the message parameter that is out of bounds. If multiple parameters are OOB, the position of the last one will be sent. For TAP_CONFIG messages, the last received parameter will stay the same (or it will be the default parameter value if no valid config message has been received yet), and a flag is raised to indicate that the last TAP_CONFIG received was invalid (CONFIG_INVALID, see below). This flag is sent each time a new TAP_OUT message is received until a valid TAP_CONFIG message is received For TAP_ALL messages, invalid parameters are replaced with hard coded default values. CONFIG_INVALID : Byte code 54 . This message is sent to the client device when a TAP_OUT message is received but the last TAP_CONFIG message had an error in it. ROW_INDEX_OOB : Byte code 55 . This message contains 2 bytes; the first is the byte code and the second is the position of the out of bounds row index. When an out of bounds index is received, the firmware will not tap an actuator, but it will still use the timing of a normal tap, and continue with the rest of the in bounds taps. If multiple indicies are out of bounds, only the position of the last one will be sent. If a column with a larger index is also OOB, it will be reported instead. COL_INDEX_OOB : Byte code 56 . This message contains 2 bytes; the first is the byte code and the second is the position of the out of bounds column index. When an out of bounds index is received, the firmware will not tap an actuator, but it will still use the timing of a normal tap, and continue with the rest of the in bounds taps. If multiple indicies are out of bounds, only the position of the last one will be sent. If a row with the same or larger index is also OOB, it will be reported instead. OVERTAP_WARNING : Byte code 57 . This message is sent to the client device when the TAP_CONFIG parameters have set the combination of onDur, repeatCT, and repeatDelay too high. onDur is automatically reduced to a safer value. DAMAGED_TAPPER : Byte code 58 . This message contains 3 bytes; the first is the byte code, the second is the row index and the third is the column index. This message is sent when the current measured for a tap doesn't exceed the minimum value considered normal/healthy. OC_EVENT : Byte code 59 . This message is sent when an overcurrent event is detected, i.e. when the on board analog circuitry detects a sustained current being drawn by the H-bridge driver ICs. The on board circuitry automatically disables the H bridge outputs. This should only happen in an event where the controller turns an output on and then somehow misses turning it off (e.g. if an SPI timing error causes a write commend to be missed) because the tap configuration settings should prevent a user from entering tap on-durations from reaching this threshold. In cases where the controller crashes mid-tap, this message will likely not be generated. BATTERY_POLL_COOLDOWN : Byte code 60 . This message is sent to the client device when the controller receives a battery poll request too quickly after a perviously sent request. OTA_TIMEOUT : Byte code 61 . This message is sent to the client device when the controller receives an OTA upload request but the user doesn't press the 'user button' before the timeout period.","title":"Communication Protocol"},{"location":"fwdocs/protocol/#communication-protocol-for-client-device-and-tappytap-driver-board","text":"This section outlines the communication protocol for a client device to connect to a the TappyTap Driver Board using Bluetooth 5 (LE). see 'script.js' in the examples folder for an implementation of this protocol.","title":"Communication Protocol for Client Device and TappyTap Driver Board"},{"location":"fwdocs/protocol/#connecting-to-the-driver-board","text":"The Driver Board advertises itself as a BLE server with the service UUID 4fafc201-1fb5-459e-8fcc-c5c9c331914b . The client device should initiate a scan for BLE devices and look for the one advertising this service UUID. Once found, the client device should establish a connection to the BLE server (the Driver Board).","title":"Connecting to the Driver Board"},{"location":"fwdocs/protocol/#sending-messages-to-the-driver-board","text":"To send a message from the client device to the Driver Board, the client device should write to the BLE characteristic with the UUID beb5483e-36e1-4688-b7f5-ea07361b26a8 .","title":"Sending Messages to the Driver Board"},{"location":"fwdocs/protocol/#sent-message-types-and-structure","text":"TAP_OUT : Byte code 1 . The message should follow this structure: Byte 0: 1 Byte 1: idenfication number that is published along with the confirmation when the TAP_OUT sequence is completed Byte 2 to n: row and column index pairs for the tap sequences. Each pair consists of the row index followed by the column index. For example, the message 0x01 0xFF 0x00 0x00 0x01 0x01 = [TAP_OUT] [Identifier (FF)] [ROW 0] [COL 0] [ROW 1] [COL 1]. Row/col pairs will be tapped out according to the parameters set with TAP_CONFIG, with the pair after the TAP_OUT byte tapped first. if there are no bytes after the identifier, the current TAP_OUT sequence will be cancelled. TAP_CONFIG : Byte code 2 . The message should follow this structure: Byte 0: 2 Byte 1: onDur (in tenths of a ms, i.e. hundreds of microseconds); range is 1-30 Byte 2: offDur (in ms); range is 10-255 Byte 3: repeatDelay (in ms); range is 2-255 Byte 4: repeatCT (number of repetitions; 1 = tap once); range is 1-5 CHECK_BATTERY : Byte code 3 . TAP_OUT_EXPLICIT : Byte code 4 . The message should follow this structure: Byte 0: 4 Byte 1: idenfication number that is published along with the confirmation when the TAP_OUT sequence is completed Byte 2 to n: row and column index pairs for the tap sequences, as well as on duration and off duration for each tap. Data is ordered as: [row] [col] [onDuration] [offDuration]. For example, the message 0x04 0xFF 0x00 0x00 0x0A 0x19 0x01 0x01 0x14 0x32 = [TAP_OUT] [Identifier (FF)] [ROW 0] [COL 0] [ON DURATION 1ms] [OFF DURATION 25ms] [ROW 1] [COL 1] [ON DURATION 2ms] [OFF DURATION 50ms]. Currently this will cause repeatCT to be set to 1 (i.e. taps are not repeated). Row/col pairs will be tapped out with the pair after the TAP_OUT byte tapped first. Note that on duration values are converted into hundreds of microseconds, e.g. 0x01 = 100us = 0.1ms. if there are no bytes after the identifier, the current TAP_OUT sequence will be cancelled. GET_VERSION : Byte code 5 . START_IMU_STREAM : Byte code 6 . STOP_IMU_STREAM : Byte code 7 . 'TAP_ALL': Byte code '8'. The message should follow this structure: Byte 0: 4 Byte 1: idenfication number that is published along with the confirmation when the TAP_OUT sequence is completed Byte 2: on duration (tenths of a millisecond) that will be used for all taps in the pattern; follows the same limits as TAP_OUT and TAP_OUT_EXPLICIT Byte 3: off duration (tenths of a milliseond - note that this is different from TAP_OUT and TAP_OUT_EXPLICIT which use ms for off duration) that will be used for all taps in the pattern. The lower limit is 0 (no delay), the upper limit is the same as for TAP_OUT and TAP_OUT_EXPLICIT. Byte 4 to n: row and column index pairs for the tap sequences","title":"Sent Message Types and Structure"},{"location":"fwdocs/protocol/#receiving-messages-from-the-driver-board","text":"The client device should also monitor the same BLE characteristic (UUID beb5483e-36e1-4688-b7f5-ea07361b26a8 ) for notifications to receive messages from the Driver Board.","title":"Receiving Messages from the Driver Board"},{"location":"fwdocs/protocol/#received-message-types-and-structure","text":"CONFRIM_RECEIVED : Byte code 1 . This message is sent to the client device to acknowledge that the sent message has been received and processed. This is only sent if the message was error free; otherwise an error code is sent instead. TAPOUT_COMPLETE : Byte code 2 . This message contains 2 bytes; the first is the byte code and the second is the identifying byte sent to the microcontroller along with the TAP_OUT command. This message is sent to the client device to indicate that the tap out sequence has been completed. BATTERY_PERCENT : Byte code 3 . This message contains 2 bytes; the first is the byte code and the second is the estimated remaining percentage of charge remaining in the battery pack. GET_VERSION : Byte code 4 . This message contains 6 bytes; the first is the byte code, then in order: hardware version number major, hardware version number minor, firmware version number major, firmware version number minor, firmware version patch. Version numbers can be read as: Hardware Version [major].[minor], Firmware Version [major].[minor].[patch]. IMU_DATA : Byte code 5 . This message contains 25 bytes; the first is the byte code and the next 24 are the 6 data values polled from the IMU (acceleration x y z and gyro x y z in that order). After collecting the data as floats, the controller multiplies them by 1000 and converts them into int32 values (preserving 3 decimal places), then splits them into 4 bytes each (MSB first). INVALID_MSG_TYPE : Byte code 51 . This message contains 2 bytes; the first is the byte code and the second is the invalid message tpye that was received INCORRECT_MSG_SIZE : Byte code 52 . This message contains 2 bytes; the first is the byte code and the second is the size of the received message, including the sent byte code PARAM_OOB : Byte code 53 . This message contains 2 bytes; the first is the byte code and the second is the position of the message parameter that is out of bounds. If multiple parameters are OOB, the position of the last one will be sent. For TAP_CONFIG messages, the last received parameter will stay the same (or it will be the default parameter value if no valid config message has been received yet), and a flag is raised to indicate that the last TAP_CONFIG received was invalid (CONFIG_INVALID, see below). This flag is sent each time a new TAP_OUT message is received until a valid TAP_CONFIG message is received For TAP_ALL messages, invalid parameters are replaced with hard coded default values. CONFIG_INVALID : Byte code 54 . This message is sent to the client device when a TAP_OUT message is received but the last TAP_CONFIG message had an error in it. ROW_INDEX_OOB : Byte code 55 . This message contains 2 bytes; the first is the byte code and the second is the position of the out of bounds row index. When an out of bounds index is received, the firmware will not tap an actuator, but it will still use the timing of a normal tap, and continue with the rest of the in bounds taps. If multiple indicies are out of bounds, only the position of the last one will be sent. If a column with a larger index is also OOB, it will be reported instead. COL_INDEX_OOB : Byte code 56 . This message contains 2 bytes; the first is the byte code and the second is the position of the out of bounds column index. When an out of bounds index is received, the firmware will not tap an actuator, but it will still use the timing of a normal tap, and continue with the rest of the in bounds taps. If multiple indicies are out of bounds, only the position of the last one will be sent. If a row with the same or larger index is also OOB, it will be reported instead. OVERTAP_WARNING : Byte code 57 . This message is sent to the client device when the TAP_CONFIG parameters have set the combination of onDur, repeatCT, and repeatDelay too high. onDur is automatically reduced to a safer value. DAMAGED_TAPPER : Byte code 58 . This message contains 3 bytes; the first is the byte code, the second is the row index and the third is the column index. This message is sent when the current measured for a tap doesn't exceed the minimum value considered normal/healthy. OC_EVENT : Byte code 59 . This message is sent when an overcurrent event is detected, i.e. when the on board analog circuitry detects a sustained current being drawn by the H-bridge driver ICs. The on board circuitry automatically disables the H bridge outputs. This should only happen in an event where the controller turns an output on and then somehow misses turning it off (e.g. if an SPI timing error causes a write commend to be missed) because the tap configuration settings should prevent a user from entering tap on-durations from reaching this threshold. In cases where the controller crashes mid-tap, this message will likely not be generated. BATTERY_POLL_COOLDOWN : Byte code 60 . This message is sent to the client device when the controller receives a battery poll request too quickly after a perviously sent request. OTA_TIMEOUT : Byte code 61 . This message is sent to the client device when the controller receives an OTA upload request but the user doesn't press the 'user button' before the timeout period.","title":"Received Message Types and Structure"}]}