{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TappyTap Documentation","text":"<p>Work in progress; documentation text and diagrams have not been added to this site yet.</p> <p>Found an error? Please let us know! You can also edit these pages using the notepad icon at the top-right of the page (you'll need to fork the docs repository, make the edits, and create a pull request).</p>"},{"location":"about/","title":"About","text":""},{"location":"hwdocs/","title":"Actuator Panels","text":"<p>TappyTap is currently available in two forms: the Swatch and the Palm. Both are intended as development tools, with the Swatch being general purpose (i.e. could be worn anywhere on your body or on another interactive surface) and the Palm being application specific (i.e. worn on your hand).</p>"},{"location":"hwdocs/#swatch","title":"Swatch","text":"<p>The Swatch is a generic sheet. It has 18x24 tappers.</p>"},{"location":"hwdocs/#palm","title":"Palm","text":"<p>The Palm is a sheet of TappyTap fabric sized for the palm of your hand (if your hand is the same size as ours).</p>"},{"location":"hwdocs/#controller","title":"Controller","text":"<p>The Controller is a Bluetooth enabled device for controlling the tappers in the fabric systems.</p>"},{"location":"hwdocs/#battery-pcb","title":"Battery PCB","text":"<p>The Battery PCB is a single cell LiPo battery protection circuit + monitor.</p>"},{"location":"hwdocs/#battery-charger","title":"Battery Charger","text":"<p>The Battery Charger can charge 2 battery packs at a time, each at 370mA peak current. </p>"},{"location":"swdocs/","title":"Dev Page Documentation","text":""},{"location":"swdocs/#installation-requirements","title":"Installation Requirements","text":"<ul> <li>install nodejs</li> <li>instal bun ( https://bun.sh )</li> </ul> <p>then in terminal, run:</p> <pre><code>bun install\n</code></pre>"},{"location":"swdocs/#running","title":"Running","text":"<p>Open two terminals, in the tapmeta directory and run:</p> <p>Terminal 1:</p> <pre><code>cd packages/tapcanvas\nbun run dev\n</code></pre> <p>Terminal 2:</p> <pre><code>cd packages/tapserver\nbun run dev\n</code></pre>"},{"location":"swdocs/#building","title":"Building","text":"<pre><code>cd packages/tapcanvas\nbun run build\n</code></pre>"},{"location":"swdocs/#running-build","title":"Running Build","text":"<pre><code>cd packages/tapcanvas\nbun run build &amp;&amp; bunx serve -n .\nhttp://localhost:3000/app-dev/\n</code></pre>"},{"location":"swdocs/#publishing","title":"Publishing","text":"<pre><code>cd packages/tapcanvas\nbun publish.js\n</code></pre>"},{"location":"swdocs/#running-chrome","title":"Running chrome:","text":"<pre><code>/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --app=\"https://localhost:8581/app-dev/\"\n</code></pre>"},{"location":"fwdocs/","title":"Firmware Documentation","text":"<ul> <li>Communication Protocol</li> <li>Controller Firmware Overview</li> <li>Battery PCB Firmware Overview</li> <li>Test Page</li> </ul>"},{"location":"fwdocs/batteryfw/","title":"Battery PCB Firmware Overview","text":"<p>The Battery PCB firmware can be found here.</p> <p>The battery pack's controller has a couple of straightforward jobs: 1. Determine the lipo cell's state of charge (SOC) from the fuel gauge IC. This is done once on a reset / power on, and then again for each 1% SOC change.  2. Tell the controller what the the current SOC when it connects, and again for each 1% SOC change as long as it is connected. 3. Display the SOC on the indicator LEDs when the button is pressed. 4. Display the charging status when the battery charger is connected.</p> <p>The firmware is summarized by this flow chart:</p> <p></p>"},{"location":"fwdocs/batteryfw/#compiling-the-firmware","title":"Compiling the Firmware","text":"<p>This project uses PlatformIO for compilation and jtag2updi for program upload. We use Visual Studio Code with the PlatformIO extension, and setup was straightforward - follow their instructions. For jtag2updi, you'll need a programmer (we use an arduino uno set up as detailed here). </p> <p>Once you've set all of that up, initiate the upload and hold the GND and UPDI wires to the contacts on the battery pack until the upload is complete. </p> <p>[reference pic needed]</p>"},{"location":"fwdocs/batteryfw/#to-dos","title":"To-Dos","text":""},{"location":"fwdocs/compiling/","title":"Compiling the Controller Firmware","text":""},{"location":"fwdocs/compiling/#building-the-firmware","title":"Building the firmware:","text":"<ul> <li>Download or build arduino libs using the instructions below to get an <code>out</code> folder.</li> <li>Install VSCode and the PlatformIO extension</li> <li>Build the project once (PlatformIO &gt; Build)</li> <li>Find your .platformio directory (probably at <code>~/.platformio/</code>). Then copy these files:</li> <li><code>out/package_esp32_index.template.json</code> to <code>~/.platformio/packages/framework-arduinoespressif32/package/</code> (the package directory isn't built by platformio by default)</li> <li><code>out/tools/esp32-arduino-libs/versions.txt</code> and <code>out/tools/esp32-arduino-libs/esp32s3</code> to <code>~/.platformio/packages/framework-arduinoespressif32/tools/sdk/.</code></li> <li>Build the project again</li> </ul> <p>Next you'll need to move the custom board json files into your platformio folder. From the repository's root directory, copy the files from <code>./boards</code> into your platformio boards directory (for example, on a Mac this would likely be in <code>/Users/[your username]/.platformio/platforms/espressif32/boards</code>). </p> <p>Once you have those set up, you should be able to hit upload and let PlatformIO handle the rest.</p>"},{"location":"fwdocs/compiling/#download-pre-built-arduino-libs","title":"Download pre-built arduino libs","text":"<p>Download <code>out.zip</code> from https://github.com/0102io/esp32-libs/releases/ and extract it.</p>"},{"location":"fwdocs/compiling/#build-arduino-libs-yourself","title":"Build arduino libs yourself","text":"<p>[!NOTE] This takes a long time and is error-prone. If possible, use the pre-built files instead.</p> <p>Create a blank github codespace on Ubuntu 20.04.6 LTS</p> <p>Run the command:</p> <pre><code>sudo apt-get update &amp;&amp;\n    sudo apt-get install -y libusb-1.0.0-dev git wget curl libssl-dev libncurses-dev flex bison gperf python python-setuptools python-cryptography python-pyparsing python-pyelftools cmake ninja-build ccache jq &amp;&amp;\n    sudo pip install --upgrade pip &amp;&amp;\n    git clone https://github.com/espressif/esp32-arduino-lib-builder &amp;&amp;\n    git clone https://github.com/0102io/TappyTap-ControllerFirmware &amp;&amp;\n    cp TappyTap-ControllerFirmware/documentation/defconfig.esp32s3 esp32-arduino-lib-builder/configs/defconfig.esp32s3 &amp;&amp;\n    cd esp32-arduino-lib-builder &amp;&amp; \n    git checkout release/v4.4 &amp;&amp; \n    ./build.sh -t esp32s3 &amp;&amp;\n    zip -FSr out.zip out\n</code></pre> <p>Download out.zip from esp32-arduino-lib-builder and extract it.</p>"},{"location":"fwdocs/controllerfw/","title":"Controller Firmware Overview","text":"<p>The controller firmware can be found here.</p> <p>The controller's primary job is to receive a set of taps via the bluetooth protocol and execute the taps with precise timing. The code is summarized by this flow chart:</p> <p></p>"},{"location":"fwdocs/controllerfw/#to-dos","title":"To-Dos","text":"<ol> <li>Reduce power consumption. So far we've managed to reduce power by using the modem-sleep config setting, auto light sleep, and disabling the 12v regulator while we're idle. This results in an idle average current draw of around ~50mA, though it is well below that in between BLE connection events and well above that during those events, which happen at least every 30ms. While tapping, with the regulator enabled, the controller itself seems to draw 150-200mA. We're hoping some wizard our there can change some other settings to bring at least the idle current draw much lower. One thing we've seen is that NimBLE might be more power efficient for bluetooth.</li> <li>Bug: really short on duration + off durations cause the controller to crash. e.g. 0.2 on / 0.5 off it crashes; 0.1 on / 0.6 off okay, 0.4 on / 0.0 off okay</li> <li>Change TapQueue to store data in the same format as a TAP_OUT message - we don't need arrays for each setting. TapHandler::tap() has to be updated accordingly.</li> <li>Add repeatCT and repeatDelay settings (ideally make the above change first though)</li> <li>Figure out what we should do with the IMU data! Orientation correction? Wake from deep sleep?</li> <li>IMU interrupts instead of polling by the ESP?</li> <li>Add HBDriver status register error notifications to the status message (see TapHandler::checkDiagnosticReg)</li> <li>Should we have some kind of auth for connecting to the controller for either normal operation or OTA uploads?</li> <li>Do something with the touch detection pins (e.g. FPC not connected notification)</li> <li>Make it so that the device type (e.g. glove, patch) can be changed through bluetooth.</li> <li>Bring back repeat tap setting.</li> <li>Send central a message with all warnings from a tapout message (e.g. index OOB)</li> <li>change IMU polling rate based on status update freq.</li> </ol>"},{"location":"fwdocs/protocol/","title":"Communication Protocol for Client Device and TappyTap Controller","text":"<p>This section outlines the communication protocol for a central device to connect to a the TappyTap Controller using Bluetooth 5 (LE). see 'script.js' in the examples folder for an implementation of this protocol.</p>"},{"location":"fwdocs/protocol/#connecting-to-the-controller","title":"Connecting to the Controller","text":"<p>The Controller advertises itself as a BLE server with the service UUID <code>4fafc201-1fb5-459e-8fcc-c5c9c331914b</code>. The client device should initiate a scan for BLE devices and look for the one advertising this service UUID. Once found, the client device should establish a connection to the BLE server (the Controller).</p>"},{"location":"fwdocs/protocol/#sending-messages-to-the-controller","title":"Sending Messages to the Controller","text":"<p>To send a message from the client device to the Controller, the central device should write to the BLE characteristic with the UUID <code>beb5483e-36e1-4688-b7f5-ea07361b26a8</code>.</p>"},{"location":"fwdocs/protocol/#sent-message-types-and-structure","title":"Sent Message Types and Structure","text":"<ul> <li> <p><code>TAP_OUT</code>: Byte code <code>1</code>. The message should follow this structure:</p> <ul> <li>Byte 0: Message type (<code>1</code>)</li> <li>Byte 1: idenfication number that is retruned by the controller along with the confirmation when the TAP_OUT sequence is completed. Sending followup TAP_OUT messages will have their contents added to the queue of taps, and the new ID will overwrite the last. Sending an ID of <code>0</code> will cancel an active pattern.</li> <li>Bytes 2 to n: sets of 6 bytes for each tap in the pattern. The 6 bytes are:    | Byte | Description |    |---|---|   | 0-1 | onDuration (MSB first). This is length of time to apply voltage to a coil, in tens of microseconds (i.e. onDuration = 20 --&gt; 200us) |   | 2-3 | offDuration (MSB first). This is the length of time before the next tap executes, in hundreds of microseconds (i.e. offDuration = 20 --&gt; 2000us) |   | 4 | Anode ID and output pin. Bits 0-3 are the output pin. Bits 4-5 are the anode ID. Bits 6-7 are unused. Bit 0 is the LSb. |   | 5 | Cathode ID and output pin. Bits 0-3 are the output pin. Bits 4-5 are the anode ID. Bits 6-7 are unused. Bit 0 is the LSb. |</li> </ul> <p>TAP_OUT example:   | Byte Value | Description |   |---|---|   | 0b00000001 | Message type (TAP_OUT)|   | 0b00000002 | TapoutID = 2 |   | 0b00000000 | onDuration MSB = 0 |   | 0b01100100 | onDuration LSB = 100, i.e. 1000us |   | 0b00000000 | offDuration MSB = 0 |   | 0b01100100 | offDuration LSB = 100, i.e. 10000us |   | 0b--010101 | Andode: ID = 1, output pin = 5 |   | 0b--101001 | Andode: ID = 3, output pin = 9 |</p> </li> <li> <p><code>GET_DEVICE_INFO</code>: Byte code <code>2</code>. Controller returns with <code>DEVICE_INFO</code> message.</p> </li> <li> <p><code>CANCEL_AND_TAP</code>: Byte code <code>3</code>. Clears the queue of taps and then loads the new taps through the same function called by TAP_OUT. This can be used to clear the queue and start a new pattern in 1 BLE pulse.</p> </li> <li> <p><code>UPDATE_STATUS_FREQUENCY</code>: Byte code <code>4</code>. A second byte with the frequency in Hz must be sent. If the requested frequency is above the limit set in the firmware, the maxiumum frequency will be used instead. If 0 is sent, the frequency will be set to 1 Hz.</p> </li> <li> <p><code>CHANGE_DEFAULT_SUBSTRATE</code>: Byte code <code>5</code>. Send with 3 more bytes for <code>substrateType</code> (1 = patch, 2 = palm/glove), <code>substrateVMajor</code>, and <code>substrateVMinor</code>. These values are saved to non-volatile memory and used to set the bluetooth device name. They can be read using <code>GET_DEVICE_INFO</code>.</p> </li> </ul>"},{"location":"fwdocs/protocol/#receiving-messages-from-the-controller","title":"Receiving Messages from the Controller","text":"<p>The client device should monitor the characteristic with UUID <code>d036e381-fd38-4376-801f-f5d90ba2ca64</code> for notifications from the Controller.</p>"},{"location":"fwdocs/protocol/#received-message-types-and-structure","title":"Received Message Types and Structure","text":"<ul> <li> <p><code>STATUS_UPDATE</code>: Byte code <code>1</code>. This message is sent to the client device at a user settable frequency. The returned bytes are as follows; unless otherwise noted, multi-byte values are all MSB first</p> Byte Description 0 Message code (STATUS_UPDATE) 1 Battery percent 2 Last received tapout id 3-4 Headroom / free space in the queue 5-8 IMU accel X (multiplied by 1000) 9-12 IMU accel Y (multiplied by 1000) 13-16 IMU accel Z (multiplied by 1000) 17-20 IMU gyro X (multiplied by 1000) 21-24 IMU gyro Y (multiplied by 1000) 25-28 IMU gyro Z (multiplied by 1000) 29-30 IMU temperature (multiplied by 10) </li> <li> <p><code>WARNING</code>: Byte code <code>2</code>. This message contains warnings, and it is sent when they occur (i.e not regularly like the status updates). This message may contain multiple error codes each with data of different lengths. The codes and types of data are as follows:</p> </li> <li><code>INVALID_MSG_TYPE</code>: Byte code <code>51</code>, + 1 data byte. The byte code is followed by the 1-byte code of the invalid message type that was received. </li> <li><code>INCORRECT_MSG_SIZE</code>: Byte code <code>52</code>, + 0 data bytes. This warning is sent when the last received message was incorrectly sized (e.g. a TAP_OUT message might be missing a setting or col index, etc.).</li> <li><code>PARAM_OOB</code>: Byte code <code>53</code>, + 2 data bytes. The byte code is followed by 2 bytes that are the MSB and LSB of the out of bounds parameter from the last <code>TAP_OUT</code> message that was last received. If multiple parameters are OOB, only the first 10 are sent as warnings. Row and column indicies that are OOB are replaced with \"empty tap\" indicies, which will make the controller pause for the onDuration to keep the pattern cadence intact. If the warning is given for an onDuration parameter (i.e. above the limit), the controller replaces the sent parameter with the maximum onDuration value defined in the firmware. Note that the returned index does not count the message type or tapout id bytes.</li> <li><code>OTA_TIMEOUT</code>: Byte code <code>61</code>, + 0 data bytes. This warning is sent when the controller receives an OTA upload request but the user doesn't press the 'interact button' before the timeout period.</li> <li><code>QUEUE_FULL</code>: Byte code <code>62</code>, + 2 data bytes. This warning is sent when the last TAP_OUT message contained more taps than could be fit into the queue. The byte code is followed by 2 bytes for the MSB and LSB of the index of the first tap that didn't fit into the queue.</li> <li><code>BOARD_OVERHEAT</code>: Byte code <code>63</code>, + 1 data byte. This warning is sent when the board temperature changes to a different \"level\", with level 0 being normal and higher levels being increasingly hot. For each level above 0, the controller attenuates the tap onDuration while keeping the pattern cadence the same. The level is included as a single byte after the warning code.</li> <li><code>OVERTAP</code>: Byte code <code>64</code>, + 2 data bytes. This warning is sent when an individual tapper is being driven at too high of a duty cycle. The following 2 bytes are the tapper's row and column indices. Similar to <code>BOARD_OVERHEAT</code>, the controller attenuates the onDuration of the taps on an over-tapped actuator, while keeping the cadence the same (by pausing without tapping).</li> <li> <p><code>HBRIDGE_DIAGNOSTIC_ERRORS</code>: Byte code <code>65</code>, + 2 data bytes. This warning is sent when an H-bridge driver chip reports a warning while it is being turned on or off for a tap. The first additional byte of data is the ID of the H-bridge chip that reported errors. The second data byte is a set of warning/error flags listed below. These warnings are described in the driver's datasheet. A warning message is only sent once when the error byte has changed.</p> <p>x (MSB) | x | OC_7TO10_ERROR | OC_1TO6_ERROR | OLD_7TO10_ERROR | OLD_1TO6_ERROR | PSF_ERROR | TW_WARNING (LSB)</p> </li> <li> <p><code>HBRIDGE_DISABLED</code>: Byte code <code>66</code>, + 0 data bytes. This warning is sent when an H-bridge disbaled event is detected. This can happen when either the overcurrent or watchdog protection circuits pull the H-bridge enable pin low, which disables the H-bridge outputs until they are written to again by the microcontroller. The overcurrent circuit trips if an output has been on for too long (200-400ms). The watchdog timer trips if the microcontroller hasn't pinged it within its timeout period.</p> </li> <li> <p><code>DEVICE_INFO</code>: Byte code <code>3</code>. This message contains configuration information that usually only needs to be passed to the client device once. The returned bytes are as follows; unless otherwise noted, multi-byte values are all MSB first</p> Byte Description 0 Message code (DEVICE_INFO) 1 Serial Number (MAC Address) first octet 2 Serial Number (MAC Address) second octet 3 Serial Number (MAC Address) third octet 4 Serial Number (MAC Address) fourth octet 5 Serial Number (MAC Address) fifth octet 6 Serial Number (MAC Address) sixth octet 7 Controller hardware version (major) 8 Controller hardware version (minor) 9 Firmware version (major) 10 Firmware version (minor) 11 Firmware version (patch) 12 Connected board type (0 for swatch, 1 for palm) 13 Connected board version (major) 14 Connected board version (minor) 15-16 Maximum tap on duration (hundredths of a ms) </li> </ul>"},{"location":"fwdocs/testPage/","title":"Test Page!","text":""}]}